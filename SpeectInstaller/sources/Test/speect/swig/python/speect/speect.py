# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
Speect is a multilingual TTS system. It offers a full text-to-speech system with
various API's, as well as an environment for research and development of TTS systems
and voices.

It is written in ANSI C and uses a plug-in mechanism for extensions. Speect also
includes an extensive set of Python bindings for quick implementation of new ideas,
these bindings are derived from SWIG (www.swig.org) interface files and can easily
be extended for other languages supported by SWIG.
"""


from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_speect', [dirname(__file__)])
        except ImportError:
            import _speect
            return _speect
        if fp is not None:
            try:
                _mod = imp.load_module('_speect', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _speect = swig_import_helper()
    del swig_import_helper
else:
    import _speect
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def errdbg_is_on():
    """

    Query whether the *Error and Debugging System* is activated or
    not. The system can be activated/deactivate with the compile time
    definition of :c:macro:`SPCT_ERROR_HANDLING`. If deactivated then no
    logging or checking of error codes will occur.

    :rtype: bool

    """
    return _speect.errdbg_is_on()

def version():
    """

    Return the Speect Engine library version in a tuple, (major version number, minor
    version number, patch name, release name).

    :rtype: tuple

    """
    return _speect.version()
class _PMapIterator(_object):
    """Proxy of C _PMapIterator struct."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _PMapIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _PMapIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_setmethods__["_itr"] = _speect._PMapIterator__itr_set
    __swig_getmethods__["_itr"] = _speect._PMapIterator__itr_get
    if _newclass:
        _itr = _swig_property(_speect._PMapIterator__itr_get, _speect._PMapIterator__itr_set)

    def __iter__(self):
        """__iter__(_PMapIterator self) -> _PMapIterator"""
        return _speect._PMapIterator___iter__(self)


    def next(self):
        """next(_PMapIterator self) -> PyObject *"""
        return _speect._PMapIterator_next(self)

    __swig_destroy__ = _speect.delete__PMapIterator
    __del__ = lambda self: None
_PMapIterator_swigregister = _speect._PMapIterator_swigregister
_PMapIterator_swigregister(_PMapIterator)


def _make_PMapIterator(itr):
    """_make_PMapIterator(SIterator * itr) -> _PMapIterator"""
    return _speect._make_PMapIterator(itr)
class _PListIterator(_object):
    """Proxy of C _PListIterator struct."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _PListIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _PListIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_setmethods__["_itr"] = _speect._PListIterator__itr_set
    __swig_getmethods__["_itr"] = _speect._PListIterator__itr_get
    if _newclass:
        _itr = _swig_property(_speect._PListIterator__itr_get, _speect._PListIterator__itr_set)

    def __iter__(self):
        """__iter__(_PListIterator self) -> _PListIterator"""
        return _speect._PListIterator___iter__(self)


    def next(self):
        """next(_PListIterator self) -> PyObject *"""
        return _speect._PListIterator_next(self)

    __swig_destroy__ = _speect.delete__PListIterator
    __del__ = lambda self: None
_PListIterator_swigregister = _speect._PListIterator_swigregister
_PListIterator_swigregister(_PListIterator)


def _make_PListIterator(itr):
    """_make_PListIterator(SIterator * itr) -> _PListIterator"""
    return _speect._make_PListIterator(itr)
class SObject(_object):
    """Proxy of C SObject struct."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SObject, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SObject, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speect.delete_SObject
    __del__ = lambda self: None

    def is_type(self, type):
        """is_type(SObject self, char const * type) -> s_bool"""
        return _speect.SObject_is_type(self, type)


    def get_type(self):
        """get_type(SObject self) -> char const *"""
        return _speect.SObject_get_type(self)

SObject_swigregister = _speect.SObject_swigregister
SObject_swigregister(SObject)

class SUtterance(_object):
    """

    SUtterance([voice = None])

    The Utterance class. An Utterance consists of a set of relations,
    which in turn consists of a set of items.

    Initialize a newly created utterance for the given voice.

    :param voice: The voice associated with this utterance.
    :type voice: :class:`SVoice`
    :return: Newly created utterance object
    :rtype: :class:`SUtterance`
    :raises: RuntimeError if Speect was unable to create the utterance.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SUtterance, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SUtterance, name)
    __repr__ = _swig_repr
    __swig_setmethods__["voice"] = _speect.SUtterance_voice_set
    __swig_getmethods__["voice"] = _speect.SUtterance_voice_get
    if _newclass:
        voice = _swig_property(_speect.SUtterance_voice_get, _speect.SUtterance_voice_set)
    __swig_setmethods__["features"] = _speect.SUtterance_features_set
    __swig_getmethods__["features"] = _speect.SUtterance_features_get
    if _newclass:
        features = _swig_property(_speect.SUtterance_features_get, _speect.SUtterance_features_set)

    def __init__(self, voice=None):
        """

        SUtterance([voice = None])

        The Utterance class. An Utterance consists of a set of relations,
        which in turn consists of a set of items.

        Initialize a newly created utterance for the given voice.

        :param voice: The voice associated with this utterance.
        :type voice: :class:`SVoice`
        :return: Newly created utterance object
        :rtype: :class:`SUtterance`
        :raises: RuntimeError if Speect was unable to create the utterance.

        """
        this = _speect.new_SUtterance(voice)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _speect.delete_SUtterance
    __del__ = lambda self: None

    def relation_new(self, name):
        """

        relation_new(name)

        Create a new named relation in the utterance.  Creates a
        relation, initializes it, and sets it in the utterance.


        :param name: The name of the new relation to create.
        :type name: str
        :return: Newly created relation object
        :rtype: :class:`SRelation`
        :raises: RuntimeError if Speect was unable to create the relation.
        :note: If a relation with the given name already exists in the utterance, then it will be deleted.

        """
        return _speect.SUtterance_relation_new(self, name)


    def relation_get(self, name):
        """

        relation_get(name)

        Get the named relation from the utterance.


        :param name: The name of the relation to get.
        :type name: str
        :return: Named relation, or ``None`` if such a relation does not exist in the utterance.
        :rtype: :class:`SRelation`

        """
        return _speect.SUtterance_relation_get(self, name)


    def relation_set(self, rel):
        """

        relation_set(rel)

        Set the given relation in the utterance.


        :param rel: The relation to set in the utterance.
        :type rel: :class:`SRelation`

        """
        return _speect.SUtterance_relation_set(self, rel)


    def relation_del(self, name):
        """

        relation_del(name)

        Delete the relation with the given name from the utterance.


        :param name: The relation to delete from the utterance.
        :type name: str

        """
        return _speect.SUtterance_relation_del(self, name)


    def __contains__(self, name):
        """

        __contains__(name)

        Test if the utterance contains the named relation.


        :param name: The relation name to test for.
        :type name: str
        :return: ``True`` or ``False``.
        :rtype: bool

        """
        return _speect.SUtterance___contains__(self, name)


    def __iter__(self):
        """

        __iter__()

        The Python iterator protocol for iteration over relation names in an utterance.

        """
        return _speect.SUtterance___iter__(self)


    def __str__(self):
        """
        Get a string representation of the utterance.

        :return: A string representation of the utterance.
        :rtype: string
        """

        stri = "Utterance:\n"
        for f in self.features:
            stri += '    Feature: %20.20s => %s\n' %(f, repr(self.features[f]))

        for r in self:
            stri += self.relation_get(r)._to_string(prefix="        ")

        return stri

SUtterance_swigregister = _speect.SUtterance_swigregister
SUtterance_swigregister(SUtterance)

class _SRelationItr(_object):
    """Proxy of C _SRelationItr struct."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _SRelationItr, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _SRelationItr, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_setmethods__["item"] = _speect._SRelationItr_item_set
    __swig_getmethods__["item"] = _speect._SRelationItr_item_get
    if _newclass:
        item = _swig_property(_speect._SRelationItr_item_get, _speect._SRelationItr_item_set)

    def __iter__(self):
        """__iter__(_SRelationItr self) -> _SRelationItr"""
        return _speect._SRelationItr___iter__(self)


    def next(self):
        """next(_SRelationItr self) -> PyObject *"""
        return _speect._SRelationItr_next(self)

    __swig_destroy__ = _speect.delete__SRelationItr
    __del__ = lambda self: None
_SRelationItr_swigregister = _speect._SRelationItr_swigregister
_SRelationItr_swigregister(_SRelationItr)


def _make_SRelationItr(rel):
    """_make_SRelationItr(SRelation rel) -> _SRelationItr"""
    return _speect._make_SRelationItr(rel)
class SRelation(_object):
    """

    SRelation(utt, name)

    The Relation class. A Relation is a named list of items. An Utterance
    can hold an arbitrary number of Relations.

    Initialize a newly created relation with the given name, and set it in
    the given utterance.


    :param utt: The utterance that the newly created relation should be placed in.
    :type utt: :class:`SUtterance`
    :param name: The name of the newly created relation.
    :type name: str
    :return: Newly created relation object.
    :rtype: :class:`SRelation`
    :raises: RuntimeError if Speect was unable to create the utterance.
    :note: Parameter *utt* may be ``None``.
    :note: A relation with the same name that already exists in the utterance will be deleted.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SRelation, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SRelation, name)
    __repr__ = _swig_repr

    def __init__(self, utt, name):
        """

        SRelation(utt, name)

        The Relation class. A Relation is a named list of items. An Utterance
        can hold an arbitrary number of Relations.

        Initialize a newly created relation with the given name, and set it in
        the given utterance.


        :param utt: The utterance that the newly created relation should be placed in.
        :type utt: :class:`SUtterance`
        :param name: The name of the newly created relation.
        :type name: str
        :return: Newly created relation object.
        :rtype: :class:`SRelation`
        :raises: RuntimeError if Speect was unable to create the utterance.
        :note: Parameter *utt* may be ``None``.
        :note: A relation with the same name that already exists in the utterance will be deleted.

        """
        this = _speect.new_SRelation(utt, name)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _speect.delete_SRelation
    __del__ = lambda self: None

    def append(self, toShare=None):
        """

        append([toShare = None])

        Create a new item and append it to the end of the items
        in the relation.


        :param toShare: The item with which the newly created item will share it's content. If ``None`` then a new content will be created for the appended item.
        :type toShare: :class:`SItem`
        :return: Newly created and appended item object.
        :rtype: :class:`SItem`
        :raises: RuntimeError if Speect was unable to create the item.

        """
        return _speect.SRelation_append(self, toShare)


    def prepend(self, toShare=None):
        """

        prepend([toShare = None])

        Create a new item and prepend it to the beginning of the items
        in the relation.


        :param toShare: The item with which the newly created item will share it's content. If ``None`` then a new content will be created for the prepended item.
        :type toShare: :class:`SItem`
        :return: Newly created and prepended item object.
        :rtype: :class:`SItem`
        :raises: RuntimeError if Speect was unable to create the item.

        """
        return _speect.SRelation_prepend(self, toShare)


    def head(self):
        """

        head()

        Get the first item in the relation.

        :return: The first item in the relation or ``None`` if the relation is empty.
        :rtype: :class:`SItem`

        """
        return _speect.SRelation_head(self)


    def tail(self):
        """

        tail()

        Get the last item in the relation.

        :return: The last item in the relation or ``None`` if the relation is empty.
        :rtype: :class:`SItem`

        """
        return _speect.SRelation_tail(self)


    def name(self):
        """

        name()

        Get the relation's name.

        :return: The relation's name.
        :rtype: str

        """
        return _speect.SRelation_name(self)


    def utterance(self):
        """

        utterance()

        Get the relation's utterance.

        :return: The relation's utterance or ``None`` if no utterance was set.
        :rtype: :class:`SUtterance`

        """
        return _speect.SRelation_utterance(self)


    def __iter__(self):
        """

        __iter__()

        The Python iterator protocol for iteration over items in a relation.

        """
        return _speect.SRelation___iter__(self)


    def __str__(self):
        """
        Get a string representation of the relation.

        :return: A string representation of the relation.
        :rtype: string
        """
        return self._to_string()


    def _to_string(self, prefix=""):
    # helper function
        stri = "%sRelation \'%s\':\n" %(prefix, self.name())
        item_prefix = "%s    " %prefix
        for i in self:
            stri += i._to_string(prefix=item_prefix)

        return stri

SRelation_swigregister = _speect.SRelation_swigregister
SRelation_swigregister(SRelation)

class SMap(_object):
    """

    A map class, an abstract data type composed of a collection of unique keys (strings) and a
    collection of values (``SObject``), where each key is associated with one value.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SMap, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def value_get(self, key):
        """

        value_get(key)

        Get the raw ``SObject`` value in the map that is associated with the given key.
        This function can be used in place of the normal::

            map['key']

        The reason for this is that the above will try to convert the returned
        value into a Python object if possible. Sometimes we want the value
        as a Speect object. So instead we can use this function::

            map.value_get('key')

        which will return the value object as it is in Speect, i.e. an ``SObject``.

        :param key: The key of the key-value pair to get.
        :type key: str
        :return: The value associated with the given key or ``None`` if no such key-value pair.
        :rtype: :class:`SObject`

        """
        return _speect.SMap_value_get(self, key)


    def __getitem__(self, key):
        """

        __getitem__(key)

        Get the value in the map that is associated with the given key.

        :param key: The key of the desired value.
        :type key: str
        :return: The value associated with the given key.
        :note: Raises ``KeyError`` if key not in map.

        """
        return _speect.SMap___getitem__(self, key)


    def __contains__(self, key):
        """

        __contains__(key)

        Query if named feature is present in this map.

        :param key: The feature key which to test for.
        :type key: str
        :return: ``True`` or ``False``.
        :rtype: bool

        """
        return _speect.SMap___contains__(self, key)


    def __len__(self):
        """

        __len__()

        Return the number of key-value pairs that are in the map.

        :return: The number of key-value pairs that are in the map.
        :rtype: int

        """
        return _speect.SMap___len__(self)


    def __setitem__(self, key, val):
        """

        __setitem__(key, value)

        Set the given key-value pair in the map.

        :param key: The key of the value.
        :type key: str
        :param value: The value of the associated key.
        :note: If a key-value pair with the given key already exists, it will be deleted.

        """
        return _speect.SMap___setitem__(self, key, val)


    def __delitem__(self, key):
        """

        __delitem__(key)

        Delete the key-value pair of the given in the map.

        :param key: The key of the key-value pair to delete.
        :type key: str

        """
        return _speect.SMap___delitem__(self, key)


    def __iter__(self):
        """

        __iter__()

        The Python iterator protocol for iteration over keys in a map.

        """
        return _speect.SMap___iter__(self)


    def __str__(self):
        """
        Return a string representation of the key-value pairs that are in the map.

        :return: A string representation of the key-value pairs that are in the map.
        :rtype: string
        """

        num_features = len(self)
        if num_features > 0:
            stri = "{ "

            first = True
            count = num_features

            for ik in self:
                if not first:
                    stri += '\n    '
                first = False
                count -= 1
                if count != 0:
                    stri += '\'%s\' : %s,' %(ik, repr(self[ik]))
                else:
                    stri += '\'%s\' : %s' %(ik, repr(self[ik]))

            if  num_features > 0:
                stri += '    }\n'

        else:
            stri = "{}"

        return stri

    __swig_destroy__ = _speect.delete_SMap
    __del__ = lambda self: None
SMap_swigregister = _speect.SMap_swigregister
SMap_swigregister(SMap)

class SList(_object):
    """

    A list class, an abstract data structure that implements an ordered collection
    of values (``SObject``), where the same value may occur more than once.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SList, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def value_get(self, n):
        """

        value_get(index)

        Get the raw ``SObject`` value in the list that is associated with the given index.
        This function can be used in place of the normal::

            list[index]

        The reason for this is that the above will try to convert the returned
        value into a Python object if possible. Sometimes we want the value
        as a Speect object. So instead we can use this function::

            list.value_get(index)

        which will return the value object as it is in Speect, i.e. an ``SObject``.

        :param index: The index of the value in the list to get.
        :type index: int
        :return: The value at the given index.
        :rtype: :class:`SObject`
        :note: Indexing starts from 0.

        """
        return _speect.SList_value_get(self, n)


    def __getitem__(self, key):
        """

        __getitem__(key)

        Get the item in the list that is associated with the given key, where the key
        is the index of the item in the list. Called to implement evaluation of::

            i = self[key]

        :param key: The index of the item in the list.
        :type key: int
        :return: The item associated with the given key (index).
        :note: Indexing starts from 0.

        """
        return _speect.SList___getitem__(self, key)


    def __len__(self):
        """

        __len__()

        Return the number of items that are in the list. Called to implement the
        built-in function::

          len()

        :return: The number of values that are in the list.
        :rtype: int

        """
        return _speect.SList___len__(self)


    def __setitem__(self, key, val):
        """

        __setitem__(key, value)

        Set the given key-value pair in the list, where the key is an index to the
        list. Called to implement assignment::

            self[key] = 10

        :param key: The index of the value in the list to set.
        :type key: int
        :param value: The value of the associated index.
        :note: The value at the given index will be deleted.
        :note: Indexing starts from 0.

        """
        return _speect.SList___setitem__(self, key, val)


    def __delitem__(self, key):
        """

        __delitem__(key)

        Delete the value at the given key (index) in the list. Called to implement deletion::

            del self[key]

        :param key: The index of the value in the list to delete.
        :type key: int
        :note: Indexing starts from 0.

        """
        return _speect.SList___delitem__(self, key)


    def __iter__(self):
        """

        __iter__()

        The Python iterator protocol for iteration over values in a list.

        """
        return _speect.SList___iter__(self)


    def __str__(self):
        """
        Return a string representation of the values that are in the list.

        :return: A string representation of the values that are in the list.
        :rtype: string
        """
        string = "["
        length = len(self)
        if length == 0:
            string += "]"
            return string
        else:
            string += " "
            for i in self:
                string += repr(i)
                length -= 1
                if length != 0:
                    string += ", "
            string += " ]";
            return string;

    __swig_destroy__ = _speect.delete_SList
    __del__ = lambda self: None
SList_swigregister = _speect.SList_swigregister
SList_swigregister(SList)

class SItem(_object):
    """

    A class for containing the items (arbitrary objects). Items are nodes in a
    relation which is again linked to an utterance. Items contain a key-value
    (string/object) set of features. An Item can have a list of daughter items as
    well. Items can be shared between relations.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SItem, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SItem, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def delete(self):
        """

        delete()

        Delete this item from it's relation. Does not delete related items from
        other relations.

        """
        return _speect.SItem_delete(self)


    def as_relation(self, relname):
        """

        as_relation(relname)

        Find the item in the given relation that has the same shared
        content as this item.

        :param relname: The relation name.
        :return: This item as it is in the named relation, or ``None`` if this item does not share it's contents with any item in the named relation.
        :rtype: :class:`SItem`

        """
        return _speect.SItem_as_relation(self, relname)


    def in_relation(self, relname):
        """

        in_relation(relname)

        Query if this item is in the named relation.

        :param relname: The relation name.
        :return: ``True`` or ``False``.
        :rtype: bool

        """
        return _speect.SItem_in_relation(self, relname)


    def next(self):
        """

        next()

        Get the item next to this one in the current relation.

        :return: The next item, or ``None`` if this is the last item in the relation.
        :rtype: :class:`SItem`

        """
        return _speect.SItem_next(self)


    def prev(self):
        """

        prev()

        Get the item previous to this one in the current relation.

        :return: The previous item, or ``None`` if this is the first item in the relation.
        :rtype: :class:`SItem`

        """
        return _speect.SItem_prev(self)


    def append(self, toShare=None):
        """

        append([toShare = None])

        Create a new item and append it after this one.

        :param toShare: The item with which the newly created item will share it's content. If ``None`` then a new content will be created for the appended item.
        :type toShare: SItem
        :return: Newly created and appended item object.
        :rtype: :class:`SItem`
        :raises: RuntimeError if Speect was unable to create the item.

        """
        return _speect.SItem_append(self, toShare)


    def prepend(self, toShare=None):
        """

        prepend([toShare = None])

        Create a new item and prepend it after this one.

        :param toShare: The item with which the newly created item will share it's content. If ``None`` then a new content will be created for the prepended item.
        :type toShare: SItem
        :return: Newly created and prepended item object.
        :rtype: :class:`SItem`
        :raises: RuntimeError if Speect was unable to create the item.

        """
        return _speect.SItem_prepend(self, toShare)


    def parent(self):
        """

        parent()

        Get this item's parent item.

        :return: The parent item of this item, or ``None`` if no parent item.
        :rtype: :class:`SItem`

        """
        return _speect.SItem_parent(self)


    def daughter(self, nth=0):
        """

        daughter([nth = 0])


        Get this item's daughter item.

        :param nth: 0 for first daughter, -1 for last daughter and *nth* > 0 for *nth* daughter.
        :type nth: int
        :return: The *nth* daughter item of this item, or ``None`` if no daughter item.
        :rtype: :class:`SItem`
        :raises: TypeError if *nth* < -1

        """
        return _speect.SItem_daughter(self, nth)


    def add_daughter(self, toShare=None):
        """

        add_daughter([toShare = None])

        Create a new item and add it as a daughter of this item.

        :param toShare: The item with which the newly created item will share it's content. If ``None`` then a new content will be created for the daughter item.
        :type toShare: SItem
        :return: Newly created daughter item object.
        :rtype: :class:`SItem`
        :raises: RuntimeError if Speect was unable to create the item.

        """
        return _speect.SItem_add_daughter(self, toShare)


    def relation(self):
        """

        relation()

        Get this item's relation.

        :return: This item's relation.
        :rtype: :class:`SRelation`

        """
        return _speect.SItem_relation(self)


    def utterance(self):
        """

        utterance()

        Get this item's utterance.

        :return: This item's utterance, or ``None`` if no utterance has been set.
        :rtype: :class:`SUtterance`

        """
        return _speect.SItem_utterance(self)


    def voice(self):
        """

        voice()

        Get this item's voice.

        :return: This item's voice, or ``None`` if no voice has been set.
        :rtype: :class:`SVoice`

        """
        return _speect.SItem_voice(self)


    def path_to_item(self, path):
        """

        path_to_item(path)

        Get the item, from the given path, relative to this item.

        :param path: The path to the desired item, relative to this item.
        :type path: str
        :return: The item from the path, relative to this item.
        :rtype: :class:`SItem`

        """
        return _speect.SItem_path_to_item(self, path)


    def feature_get(self, key):
        """

        feature_get(key)

        Get the raw ``SObject`` feature of the item that is associated with the given key.
        This function can be used in place of the normal::

            item['feature_name']

        The reason for this is that the above will try to convert the returned
        feature into a Python object if possible. Sometimes we want the feature
        as a Speect object. So instead we can use this function::

            item.feature_get('feature_name')

        which will return the feature object as it is in Speect, i.e. an ``SObject``.

        :param key: The key of the key-value pair to get.
        :type key: str
        :return: The feature associated with the given key or ``None`` if no such key-value pair.
        :rtype: :class:`SObject`

        """
        return _speect.SItem_feature_get(self, key)


    def __eq__(self, other):
        """

        __eq__(item)

        Query if the given item equals this one. Equal meaning they
        share the same contents.

        :param item: The item to test against.
        :type item: SItem
        :return: ``True`` or ``False``.
        :rtype: bool

        """
        return _speect.SItem___eq__(self, other)


    def __len__(self):
        """

        __len__()

        Get the number of features in this item.

        :return: The number of features in this item.
        :rtype: int

        """
        return _speect.SItem___len__(self)


    def __contains__(self, feat_name):
        """

        __contains__(feat_name)

        Query if named feature is present in this item.

        :param feat_name: The feature key which to test for.
        :type feat_name: str
        :return: ``True`` or ``False``.
        :rtype: bool

        """
        return _speect.SItem___contains__(self, feat_name)


    def path_to_feature(self, path):
        """

        path_to_feature(path)

        Get the item feature, from the given path, relative to this item.

        :param path: The path to the desired item's feature, relative to this item.
        :type path: str
        :return: The feature object from the path, relative to this item.

        """
        return _speect.SItem_path_to_feature(self, path)


    def path_to_derived_feature(self, path):
        """

        path_to_derived_feature(path)

        Execute the given *feature processor*, on the item from the
        given path, relative to the given item. The name of the feature
        processor is the last element of the path.

        :param path: The path to the desired item, relative to this item, with the last element being the name of the feature processor.
        :type path: str
        :return: The extracted feature object from the path, relative to this item.

        """
        return _speect.SItem_path_to_derived_feature(self, path)


    def path(self, path):
        """

        path(path)

        Follow the given path, relative to the given item, and return the
        object at the path. The object may be another item, a feature, or a
        feature that has been calculated by a *feature processor*.
        This function can be used as a replacement for :meth:`SItem.path_to_derived_feature`,
        :meth:`SItem.path_to_item`, or :meth:`SItem.path_to_item`.

        :param path: The path to the desired item, feature, or feature processor, relative to the given item.
        :type path: str
        :return: The object at the end of the path, which may be another item, a item feature, or a feature that has been calculated by a feature processor.

        """
        return _speect.SItem_path(self, path)


    def __getitem__(self, key):
        """

        __getitem__(key)

        Get the key-value feature pair.

        :param key: The desired feature's key.
        :type key: str
        :return: The feature's value object, or ``None`` if no such key-value pair.
        :rtype: SObject

        """
        return _speect.SItem___getitem__(self, key)


    def __setitem__(self, key, val):
        """

        __setitem__(key, value)

        Set the key-value feature pair.

        :param key: The feature's key.
        :type key: str
        :param value: The feature's value object.
        :type value: SObject
        :note: An existing key-value pair in the item's features with the given key will be deleted.

        """
        return _speect.SItem___setitem__(self, key, val)


    def __delitem__(self, key):
        """

        __delitem__(key)

        Delete the key-value feature pair.

        :param key: The feature's key.
        :type key: str

        """
        return _speect.SItem___delitem__(self, key)


    def __iter__(self):
        """

        __iter__()

        The Python iterator protocol for iteration over item features.

        """
        return _speect.SItem___iter__(self)


    def __str__(self):
        """
        Get a string representation of the item.

        :return: A string representation of the item.
        :rtype: string
        """
        return self._to_string()


    def _to_string(self, prefix="", label="Item"):
    # helper function
        label_spacing = ''
        for s in range(0, len(label)):
            label_spacing += ' '

        num_features = len(self)
        if num_features > 0:
            stri = "%s%s: [ " %(prefix,label)

            first = True
            count = num_features

            for ik in self:
                if not first:
                    stri += '\n%s%s    ' %(prefix, label_spacing)
                first = False
                count -= 1
                if count != 0:
                    stri += '%15.15s => %s,' %(ik, repr(self[ik]))
                else:
                    stri += '%15.15s => %s' %(ik, repr(self[ik]))

            if  num_features > 0:
                stri += '    ]\n'

        else:
            stri = ""

        i = self.daughter()
        n = 0
        daughter_prefix = '%s    ' %prefix
        while i:
            stri += '%s' %i._to_string(prefix=daughter_prefix,
                                     label='Daughter')
            n += 1
            i = self.daughter(n)

        return stri

SItem_swigregister = _speect.SItem_swigregister
SItem_swigregister(SItem)

class SVoice(_object):
    """

    SVoice(path)

    Load a voice, from the voice configuration at the given path. If any
    of the voice's data objects have already been loaded, then they are shared.
    This reduces the need for multiple redundant calls.

    :param path: The name of the voice configuration file to load.
    :type path: str
    :return: Voice object
    :rtype: :class:`SVoice`
    :raises: RuntimeError if Speect was unable to load the voice.
    :note: The ``path`` can be an absolute or relative path to the voice configuration file.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SVoice, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SVoice, name)
    __repr__ = _swig_repr
    __swig_setmethods__["features"] = _speect.SVoice_features_set
    __swig_getmethods__["features"] = _speect.SVoice_features_get
    if _newclass:
        features = _swig_property(_speect.SVoice_features_get, _speect.SVoice_features_set)
    __swig_destroy__ = _speect.delete_SVoice
    __del__ = lambda self: None

    def synth(self, *args):
        """

        synth(input[, utt_type='text'])


        Synthesize an utterance of the given utterance type with the voice.

        :param input: The text to synthesize.
        :type input: str
        :param utt_type: The utterance type to synthesize.
        :type utt_type: str
        :return: The synthesized utterance.
        :rtype: :class:`SUtterance`

        """
        return _speect.SVoice_synth(self, *args)


    def resynth(self, utt, utt_type):
        """

        resynth(utt, utt_type)

        Re-synthesize an utterance with the given utterance type. This
        is used when an utterance was synthesized with a certain utterance type,
        and now it must be synthesized with a different utterance type.

        :param utt: The utterance to re-synthesize.
        :type utt: :class:`SUtterance`
        :param utt_type: The utterance type for re-synthesis.
        :type utt_type: str

        """
        return _speect.SVoice_resynth(self, utt, utt_type)


    def name(self):
        """

        name()

        Get the voice's name.

        :return: The name of the voice.
        :rtype: str

        """
        return _speect.SVoice_name(self)


    def description(self):
        """

        description()

        Get the voice's description.

        :return: The description of the voice.
        :rtype: str

        """
        return _speect.SVoice_description(self)


    def gender(self):
        """

        gender()

        Get the voice's gender.

        :return: The gender of the voice.
        :rtype: str

        """
        return _speect.SVoice_gender(self)


    def language(self):
        """

        language()

        Get the voice's language.

        :return: The language of the voice.
        :rtype: str

        """
        return _speect.SVoice_language(self)


    def lang_code(self):
        """

        lang_code()

        Get the voice's ``ISO 639-2`` language code.

        :return: The ``ISO 639-2`` language code of the voice.
        :rtype: str

        """
        return _speect.SVoice_lang_code(self)


    def version(self):
        """

        version()

        Get the voice's version.

        :return: The version of the voice (major, minor).
        :rtype: tuple

        """
        return _speect.SVoice_version(self)


    def data_del(self, key):
        """

        data_del(key)

        Delete the voice data object referenced by the given key.

        :param key: The key of the data object.
        :type key: str

        """
        return _speect.SVoice_data_del(self, key)


    def uttType_del(self, key):
        """

        uttType_del(key)

        Delete the voice utterance type definition referenced by the given key.

        :param key: The key of the utterance type definition.
        :type key: str

        """
        return _speect.SVoice_uttType_del(self, key)


    def uttProcessor_set(self, key, uttProc):
        """

        uttProcessor_set(key, uttProc)

        Set an utterance processor, with the given key, in the voice.

        :param key: The key of the utterance processor.
        :type key: str
        :param uttProc: The utterance processor.
        :type uttProc: :class:`SUttProcessor`

        """
        return _speect.SVoice_uttProcessor_set(self, key, uttProc)


    def uttProcessor_get(self, key):
        """

        uttProcessor_get(key)

        Return the voice utterance processor reference by the given key.

        :param key: The key of the utterance processor as referenced in the voice.
        :type key: str
        :return: The utterance processor or ``None`` if no such definition exists.
        :rtype: :class:`SUttProcessor`

        """
        return _speect.SVoice_uttProcessor_get(self, key)


    def uttProcessor_del(self, key):
        """

        uttProcessor_del(key)

        Delete the voice utterance processor referenced by the given key.

        :param key: The key of the utterance processor.
        :type key: str

        """
        return _speect.SVoice_uttProcessor_del(self, key)


    def featProcessor_set(self, key, featProc):
        """

        featProcessor_set(key, featProc)

        Set a feature processor, with the given key, in the voice.

        :param key: The key of the feature processor.
        :type key: str
        :param featProc: The feature processor.
        :type featProc: :class:`SFeatProcessor`

        """
        return _speect.SVoice_featProcessor_set(self, key, featProc)


    def featProcessor_get(self, key):
        """

        featProcessor_get(key)

        Return the voice feature processor reference by the given key.

        :param key: The key of the feature processor as referenced in the voice.
        :type key: str
        :return: The feature processor or ``None`` if no such definition exists.
        :rtype: :class:`SFeatProcessor`

        """
        return _speect.SVoice_featProcessor_get(self, key)


    def featProcessor_del(self, key):
        """

        featProcessor_del(key)

        Delete the voice feature processor referenced by the given key.

        :param key: The key of the feature processor.
        :type key: str

        """
        return _speect.SVoice_featProcessor_del(self, key)

    __swig_setmethods__["uttTypes"] = _speect.SVoice_uttTypes_set
    __swig_getmethods__["uttTypes"] = _speect.SVoice_uttTypes_get
    if _newclass:
        uttTypes = _swig_property(_speect.SVoice_uttTypes_get, _speect.SVoice_uttTypes_set)
    __swig_setmethods__["uttProcessors"] = _speect.SVoice_uttProcessors_set
    __swig_getmethods__["uttProcessors"] = _speect.SVoice_uttProcessors_get
    if _newclass:
        uttProcessors = _swig_property(_speect.SVoice_uttProcessors_get, _speect.SVoice_uttProcessors_set)
    __swig_setmethods__["dataObjects"] = _speect.SVoice_dataObjects_set
    __swig_getmethods__["dataObjects"] = _speect.SVoice_dataObjects_get
    if _newclass:
        dataObjects = _swig_property(_speect.SVoice_dataObjects_get, _speect.SVoice_dataObjects_set)
    __swig_setmethods__["featProcessors"] = _speect.SVoice_featProcessors_set
    __swig_getmethods__["featProcessors"] = _speect.SVoice_featProcessors_get
    if _newclass:
        featProcessors = _swig_property(_speect.SVoice_featProcessors_get, _speect.SVoice_featProcessors_set)

    def __init__(self, path):
        """

        SVoice(path)

        Load a voice, from the voice configuration at the given path. If any
        of the voice's data objects have already been loaded, then they are shared.
        This reduces the need for multiple redundant calls.

        :param path: The name of the voice configuration file to load.
        :type path: str
        :return: Voice object
        :rtype: :class:`SVoice`
        :raises: RuntimeError if Speect was unable to load the voice.
        :note: The ``path`` can be an absolute or relative path to the voice configuration file.

        """
        this = _speect.new_SVoice(path)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def uttType_set(self, key, uttType):
        """

        uttType_set(key, uttType)

        Set an utterance type definition, with the given key, in the voice.

        :param key: The key of the utterance type.
        :type key: str
        :param uttType: The utterance type definition.
        :type uttType: list

        """
        return _speect.SVoice_uttType_set(self, key, uttType)


    def uttType_get(self, key):
        """

        uttType_get(key)

        Return the voice utterance type definition reference by the given key.

        :param key: The key of the utterance type definition as referenced in the voice.
        :type key: str
        :return: The utterance type definition or ``None`` if no such definition exists.
        :rtype: :class:`SList` or list

        """
        return _speect.SVoice_uttType_get(self, key)


    def data_set(self, key, pobject):
        """

        data_set(key, object)

        Set a data object, with the given key, in the voice.

        :param key: The key of the data object.
        :type key: str
        :type object: any object type.
        :note: If the given key references a data object present in the voice, then that data object will be deleted.

        """
        return _speect.SVoice_data_set(self, key, pobject)


    def data_get(self, key):
        """

        data_get(key)

        Return the voice data object reference by the given key.

        :param key: The key of the data object as referenced in the voice.
        :type key: str
        :return: The data object or ``None`` if no such object exists.

        """
        return _speect.SVoice_data_get(self, key)

SVoice_swigregister = _speect.SVoice_swigregister
SVoice_swigregister(SVoice)

class SPlugin(_object):
    """

    SPlugin(path)

    Plug-in objects encapsulate the loading/unloading and resource acquisition
    of *dynamic shared objects*.

    Load a plug-in from the given path. If the plug-in at the given
    path has already been loaded, then the plug-in's reference counter
    is increased and a pointer to the loaded plug-in is returned. This
    reduces the need for multiple redundant calls.

    If the given path does not include any path separators (just a file name)
    then the path is concatenated with the default plug-in path.

    :param path: The full path and name of the plug-in to load.
    :type path: str
    :return: Plug-in object
    :rtype: :class:`SPlugin`
    :raises: RuntimeError if Speect was unable to load the plug-in.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SPlugin, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SPlugin, name)
    __repr__ = _swig_repr

    def __init__(self, path):
        """

        SPlugin(path)

        Plug-in objects encapsulate the loading/unloading and resource acquisition
        of *dynamic shared objects*.

        Load a plug-in from the given path. If the plug-in at the given
        path has already been loaded, then the plug-in's reference counter
        is increased and a pointer to the loaded plug-in is returned. This
        reduces the need for multiple redundant calls.

        If the given path does not include any path separators (just a file name)
        then the path is concatenated with the default plug-in path.

        :param path: The full path and name of the plug-in to load.
        :type path: str
        :return: Plug-in object
        :rtype: :class:`SPlugin`
        :raises: RuntimeError if Speect was unable to load the plug-in.

        """
        this = _speect.new_SPlugin(path)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _speect.delete_SPlugin
    __del__ = lambda self: None
SPlugin_swigregister = _speect.SPlugin_swigregister
SPlugin_swigregister(SPlugin)

class SUttProcessor(_object):
    """

    An Utterance Processor processes an utterance by extracting information from it
    and then modifying it in some way.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SUttProcessor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SUttProcessor, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_setmethods__["features"] = _speect.SUttProcessor_features_set
    __swig_getmethods__["features"] = _speect.SUttProcessor_features_get
    if _newclass:
        features = _swig_property(_speect.SUttProcessor_features_get, _speect.SUttProcessor_features_set)

    def run(self, utt):
        """

        run(utt)

        Execute the UttProcessor on the given utterance.

        :param utt: The utterance on which to execute the utterance processor.
        :type utt: :class:`SUtterance`

        """
        return _speect.SUttProcessor_run(self, utt)

SUttProcessor_swigregister = _speect.SUttProcessor_swigregister
SUttProcessor_swigregister(SUttProcessor)


def _s_get_plugin_info(path):
    """_s_get_plugin_info(char const * path) -> PyObject *"""
    return _speect._s_get_plugin_info(path)

def get_plugin_info(path):
    """
    get_plugin_info(path)

    Get information on the plug-in at the given path.
    If the given path does not include any path separators (just a file name)
    then the path is concatenated with the default plug-in path.

    :param path: Path to plug-in file.
    :type path: str
    :return: A dictionary with information on the given plug-in.
    :rtype: dict
    """
    if not isinstance(path, str):
        raise TypeError("Argument \"path\" must be a string")

    return _s_get_plugin_info(path)


def _s_set_speect_py_logger(logger):
    """_s_set_speect_py_logger(PyObject * logger)"""
    return _speect._s_set_speect_py_logger(logger)

def setLogger(logger):
    """
    Set the given logger (instance of the logging.Logger
    module) as the logger to be used by the Speect Engine
    for error and debugging purposes.

    :param logger: The logger to be used by the Speect Engine.
    :type logger: Instance of the logging.Logger module
    """

    import logging

    if not isinstance(logger, logging.Logger):
        raise TypeError("'logger' must be an instance of the logging.Logger module")

    _s_set_speect_py_logger(logger)

class SFeatProcessor(_object):
    """

    A Feature Processor processes an item by extracting information from it
    and returning this extracted information.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SFeatProcessor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SFeatProcessor, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def run(self, item):
        """

        run(item)

        Execute the FeatProcessor on the given item.

        :param item: The item on which to execute the feature processor.
        :type item: :class:`SItem`
        :return: The extracted information object (can be any object).

        """
        return _speect.SFeatProcessor_run(self, item)

SFeatProcessor_swigregister = _speect.SFeatProcessor_swigregister
SFeatProcessor_swigregister(SFeatProcessor)

# This file is compatible with both classic and new-style classes.


